<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hluck.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="笔记出自HenCoder Android 开发进阶: 自定义 View 1-1 绘制基础 更多内容Android自定义View全解 自定义绘制概述 自定义绘制的方式是重写绘制方法，其中最常用的是 onDraw()  绘制的关键是 Canvas 的使用  Canvas 的绘制类方法： drawXXX() （关键参数：Paint） Canvas 的辅助类方法：范围裁切和几何变换   可以使用不同的绘制">
<meta property="og:type" content="article">
<meta property="og:title" content="自定义View一">
<meta property="og:url" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/index.html">
<meta property="og:site_name" content="余一">
<meta property="og:description" content="笔记出自HenCoder Android 开发进阶: 自定义 View 1-1 绘制基础 更多内容Android自定义View全解 自定义绘制概述 自定义绘制的方式是重写绘制方法，其中最常用的是 onDraw()  绘制的关键是 Canvas 的使用  Canvas 的绘制类方法： drawXXX() （关键参数：Paint） Canvas 的辅助类方法：范围裁切和几何变换   可以使用不同的绘制">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/1.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/2.jpg">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/3.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/4.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/5.jpg">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/6.jpg">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/7.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/8.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/9.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/10.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/11.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/12.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/13.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/14.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/15.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/16.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/48.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/17.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/18.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/19.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/20.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/21.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/23.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/24.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/49.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/50.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/25.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/26.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/27.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/28.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/29.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/30.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/31.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/32.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/33.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/34.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/35.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/36.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/37.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/38.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/39.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/40.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/41.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/42.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/43.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/44.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/45.png">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/46.jpg">
<meta property="og:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/47.png">
<meta property="article:published_time" content="2022-06-28T10:33:25.155Z">
<meta property="article:modified_time" content="2022-08-10T15:42:33.509Z">
<meta property="article:author" content="余一">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/1.png">

<link rel="canonical" href="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>自定义View一 | 余一</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="余一" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">余一</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">纸上得来终觉浅，绝知此事要躬行。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hluck.github.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar5.jpg">
      <meta itemprop="name" content="余一">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余一">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          自定义View一
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-28 18:33:25" itemprop="dateCreated datePublished" datetime="2022-06-28T18:33:25+08:00">2022-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 23:42:33" itemprop="dateModified" datetime="2022-08-10T23:42:33+08:00">2022-08-10</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>笔记出自<a href="https://juejin.cn/post/6844903486807785485#heading-0" target="_blank" rel="noopener">HenCoder Android 开发进阶: 自定义 View 1-1 绘制基础</a></p>
<p>更多内容<a href="https://www.jianshu.com/p/705a6cb6bfee" target="_blank" rel="noopener">Android自定义View全解</a></p>
<h2 id="自定义绘制概述"><a href="#自定义绘制概述" class="headerlink" title="自定义绘制概述"></a>自定义绘制概述</h2><ol>
<li><p>自定义绘制的方式是重写绘制方法，其中最常用的是 onDraw()</p>
</li>
<li><p>绘制的关键是 Canvas 的使用</p>
<ul>
<li>Canvas 的绘制类方法： drawXXX() （关键参数：Paint）</li>
<li>Canvas 的辅助类方法：范围裁切和几何变换</li>
</ul>
</li>
<li><p>可以使用不同的绘制方法来控制遮盖关系</p>
<a id="more"></a>
<h2 id="自定义绘制知识的四个级别"><a href="#自定义绘制知识的四个级别" class="headerlink" title="自定义绘制知识的四个级别"></a>自定义绘制知识的四个级别</h2></li>
<li><p>Canvas 的 drawXXX() 系列方法及 <code>Paint</code> 最常见的使用</p>
</li>
</ol>
<p>​    <code>Canvas.drawXXX()</code> 是自定义绘制最基本的操作。掌握了这些方法，你才知道怎么绘制内容，例如怎么画圆、怎么画方、怎么画图像和文字。组合绘制这些内容，再配合上 <code>Paint</code> 的一些常见方法来对绘制内容的颜色和风格进行简单的配置，就能够应付大部分的绘制需求了。</p>
<ol start="2">
<li><strong><code>Paint</code> 的完全攻略</strong></li>
</ol>
<p>​    <code>Paint</code> 可以做的事，不只是设置颜色，也不只是实心空心、线条粗细、有没有阴影，它可以做的风格设置真的是非常多、非常细。例如：</p>
<pre><code>拐角要什么形状？</code></pre><p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/1.png" alt></p>
<p>​        开不开双线性过滤？</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/2.jpg" alt></p>
<p>​        加不加特效？</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/3.png" alt></p>
<p>可以调节的非常多…</p>
<ol start="3">
<li><p><strong><code>Canvas</code> 对绘制的辅助——范围裁切和几何变换。</strong></p>
<p>​    范围裁切：</p>
</li>
</ol>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/4.png" alt></p>
<p>​            几何变换：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/5.jpg" alt></p>
<ol start="4">
<li><strong>使用不同的绘制方法来控制绘制顺序</strong></li>
</ol>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/6.jpg" alt></p>
<p>​        控制绘制顺序解决的并不是「做不到」的问题，而是性能问题。同样的一种效果，你不用绘制顺序的控制往往也能做到，但需要用多个 View 甚至是多层 View 才能拼凑出来，因此代价是 UI 的性能；而使用绘制顺序的控制的话，一个 View 就全部搞定了。</p>
<h2 id="一切的开始：onDraw"><a href="#一切的开始：onDraw" class="headerlink" title="一切的开始：onDraw()"></a>一切的开始：onDraw()</h2><p>​        自定义绘制的上手非常容易：提前创建好 <code>Paint</code> 对象，重写 <code>onDraw()</code>，把绘制代码写在 <code>onDraw()</code> 里面，就是自定义绘制最基本的实现。大概就像这样：</p>
<p>kotlin:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCircle</span></span>(context: Context,attr:AttributeSet?):View(context,attr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        canvas?.drawCircle(<span class="number">300F</span>,<span class="number">300F</span>,<span class="number">200F</span>,paint)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制一个圆</span></span><br><span class="line">    canvas.drawCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        就这么简单。所以关于 <code>onDraw()</code> 其实没什么好说的，一个很普通的方法重写，唯一需要注意的是<strong>别漏写</strong>了 <code>super.onDraw()</code>。</p>
<h2 id="Canvas-drawXXX-和-Paint-基础"><a href="#Canvas-drawXXX-和-Paint-基础" class="headerlink" title="Canvas.drawXXX() 和 Paint 基础"></a>Canvas.drawXXX() 和 Paint 基础</h2><p><code>drawXXX()</code> 系列方法和 <code>Paint</code> 的基础掌握了，就能够应付简单的绘制需求。它们主要包括：</p>
<ol>
<li><code>Canvas</code> 类下的所有 <code>draw-</code> 打头的方法，例如 <code>drawCircle()</code> <code>drawBitmap()</code>。</li>
<li><code>Paint</code> 类的几个最常用的方法。具体是：<ul>
<li><code>Paint.setStyle(Style style)</code> 设置绘制模式</li>
<li><code>Paint.setColor(int color)</code> 设置颜色</li>
<li><code>Paint.setStrokeWidth(float width)</code> 设置线条宽度</li>
<li><code>Paint.setTextSize(float textSize)</code> 设置文字大小</li>
<li><code>Paint.setAntiAlias(boolean aa)</code> 设置抗锯齿开关</li>
</ul>
</li>
</ol>
<h3 id="颜色填充"><a href="#颜色填充" class="headerlink" title="颜色填充"></a>颜色填充</h3><p><strong>Canvas.drawColor(@ColorInt int color)</strong> </p>
<p>​        这是最基本的 <code>drawXXX()</code> 方法：在整个绘制区域统一涂上指定的颜色。</p>
<p>​        例如 <code>drawColor(Color.BLACK)</code> 会把整个区域染成纯黑色，覆盖掉原有内容； <code>drawColor(Color.parse(&quot;#88880000&quot;)</code> 会在原有的绘制效果上加一层半透明的红色遮罩。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawColor(Color.BLACK);  <span class="comment">// 纯黑</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/7.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawColor(Color.parse(<span class="string">"#88880000"</span>); <span class="comment">// 半透明红色</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/8.png" alt></p>
<p>​        类似的方法还有 <code>drawRGB(int r, int g, int b)</code> 和 <code>drawARGB(int a, int r, int g, int b)</code> ，它们和 <code>drawColor(color)</code> 只是使用方式不同，作用都是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawRGB(<span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">canvas.drawARGB(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong>这类颜色填充方法一般用于在绘制之前设置底色，或者在绘制之后为界面设置半透明蒙版。</strong></p>
<h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><p><strong>drawCircle(float centerX, float centerY, float radius, Paint paint)</strong> </p>
<p>​        前两个参数 <code>centerX</code> <code>centerY</code> 是圆心的坐标，第三个参数 <code>radius</code> 是圆的半径，单位都是像素，它们共同构成了这个圆的基本信息（即用这几个信息可以构建出一个确定的圆）；第四个参数 <code>paint</code> ，它提供基本信息之外的所有风格信息，例如颜色、线条粗细、阴影等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/9.png" alt></p>
<h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p>​        在 Android 里，每个 View 都有一个自己的坐标系，彼此之间是不影响的。这个坐标系的原点是 View 左上角的那个点；水平方向是 x 轴，右正左负；竖直方向是 y 轴，下正上负（注意，是下正上负，不是上正下负，和上学时候学的坐标系方向不一样）。也就是下面这个样子。</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/10.png" alt></p>
<p>​        所以一个 View 的坐标 (x, y) 处，指的就是相对它的左上角那个点的水平方向 x 像素、竖直方向 y 像素的点。例如，(300, 300) 指的就是左上角的点向右 300 、向下 300 的位置； (100, -50) 指的就是左上角的点向右 100 、向上 50 的位置。</p>
<p>​        也就是说， <code>canvas.drawCircle(300, 300, 200, paint)</code> 这行代码绘制出的圆，在 View 中的位置和尺寸应该是这样的：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/11.png" alt></p>
<p>​        圆心坐标和半径，这些都是圆的基本信息，也是它的独有信息。什么叫独有信息？就是只有它有，别人没有的信息。你画圆有圆心坐标和半径，画方有吗？画椭圆有吗？这就叫独有信息。独有信息都是直接作为参数写进 <code>drawXXX()</code> 方法里的（比如 <code>drawCircle(centerX, centerY, radius, paint)</code> 的前三个参数）。</p>
<p>​        而除此之外，其他的都是公有信息。比如图形的颜色、空心实心这些，你不管是画圆还是画方都有可能用到的，这些信息则是统一放在 <code>paint</code> 参数里的。</p>
<h3 id="Paint-setColor-int-color"><a href="#Paint-setColor-int-color" class="headerlink" title="Paint.setColor(int color)"></a>Paint.setColor(int color)</h3><p>​        例如，你要画一个红色的圆，并不是写成 <code>canvas.drawCircle(300, 300, 200, RED, paint)</code> 这样，而是像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paint.setColor(Color.RED); <span class="comment">// 设置为红色</span></span><br><span class="line">canvas.drawCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/12.png" alt></p>
<p>​        <code>Paint.setColor(int color)</code> 是 <code>Paint</code> 最常用的方法之一，用来设置绘制内容的颜色。你不止可以用它画红色的圆，也可以用它来画红色的矩形、红色的五角星、红色的文字。</p>
<h3 id="Paint-setStyle-Paint-Style-style"><a href="#Paint-setStyle-Paint-Style-style" class="headerlink" title="Paint.setStyle(Paint.Style style)"></a>Paint.setStyle(Paint.Style style)</h3><p>​        而如果你想画的不是实心圆，而是空心圆（或者叫环形），也可以使用 <code>paint.setStyle(Paint.Style.STROKE)</code> 来把绘制模式改为画线模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.STROKE); <span class="comment">// Style 修改为画线模式</span></span><br><span class="line">canvas.drawCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/13.png" alt></p>
<p>​        <code>setStyle(Style style)</code> 这个方法设置的是绘制的 <code>Style</code> 。<code>Style</code> 具体来说有三种： <code>FILL</code>, <code>STROKE</code> 和 <code>FILL_AND_STROKE</code> 。<code>FILL</code> 是填充模式，<code>STROKE</code> 是画线模式（即勾边模式），<code>FILL_AND_STROKE</code> 是两种模式一并使用：既画线又填充。它的默认值是 <code>FILL</code>，填充模式。</p>
<h3 id="Paint-setStrokeWidth-float-width"><a href="#Paint-setStrokeWidth-float-width" class="headerlink" title="Paint.setStrokeWidth(float width)"></a>Paint.setStrokeWidth(float width)</h3><p>​        在 <code>STROKE</code> 和 <code>FILL_AND_STROKE</code> 下，还可以使用 <code>paint.setStrokeWidth(float width)</code> 来设置线条的宽度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">paint.setStrokeWidth(<span class="number">20</span>); <span class="comment">// 线条宽度为 20 像素</span></span><br><span class="line">canvas.drawCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/14.png" alt></p>
<h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><p>​        在绘制的时候，往往需要开启抗锯齿来让图形和文字的边缘更加平滑。开启抗锯齿很简单，只要在 <code>new Paint()</code> 的时候加上一个 <code>ANTI_ALIAS_FLAG</code> 参数就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br></pre></td></tr></table></figure>

<p>​        另外，你也可以使用 <code>Paint.setAntiAlias(boolean aa)</code> 来动态开关抗锯齿。</p>
<p>抗锯齿的效果如下：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/15.png" alt></p>
<p>可以看出，没有开启抗锯齿的时候，图形会有毛片现象，啊不，毛边现象。所以一定记得要打开抗锯齿哟！</p>
<p>​        为什么抗锯齿开启之后的图形边缘会更加平滑呢？因为抗锯齿的原理是：修改图形边缘处的像素颜色，从而<strong>让图形在肉眼看来具有更加平滑的感觉</strong>。一图胜千言，上图：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/16.png" alt></p>
<p>​        除了圆，<code>Canvas</code> 还可以绘制一些别的简单图形。它们的使用方法和 <code>drawCircle()</code> 大同小异，我就只对它们的 API 做简单的介绍，不再做详细的讲解。</p>
<h3 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h3><p>​        drawRect(float left, float top, float right, float bottom, Paint paint) </p>
<p>​        <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 是矩形四条边的坐标。</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/48.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Style.FILL);</span><br><span class="line"><span class="comment">//宽：right 500 - left 100</span></span><br><span class="line"><span class="comment">//高: bottom - top</span></span><br><span class="line">canvas.drawRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Style.STROKE);</span><br><span class="line">canvas.drawRect(<span class="number">700</span>, <span class="number">100</span>, <span class="number">1100</span>, <span class="number">500</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/17.png" alt></p>
<p>​        另外，它还有两个重载方法 <code>drawRect(RectF rect, Paint paint)</code> 和 <code>drawRect(Rect rect, Paint paint)</code> ，让你可以直接填写 <code>RectF</code> 或 <code>Rect</code> 对象来绘制矩形。</p>
<h3 id="画点"><a href="#画点" class="headerlink" title="画点"></a>画点</h3><p>​        drawPoint(float x, float y, Paint paint)</p>
<p>​        <code>x</code> 和 <code>y</code> 是点的坐标。点的大小可以通过 <code>paint.setStrokeWidth(width)</code> 来设置；点的形状可以通过 <code>paint.setStrokeCap(cap)</code> 来设置：<code>ROUND</code> 画出来是圆形的点，<code>SQUARE</code> 或 <code>BUTT</code> 画出来是方形的点。</p>
<p>​        <strong>注意</strong>：<code>Paint.setStrokeCap(cap)</code> 可以设置点的形状，但这个方法并不是专门用来设置点的形状的，而是一个设置线条端点形状的方法。端点有圆头 (<code>ROUND</code>)、平头 (<code>BUTT</code>) 和方头 (<code>SQUARE</code>) 三种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paint.setStrokeWidth(<span class="number">20</span>);</span><br><span class="line">paint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line">canvas.drawPoint(<span class="number">50</span>, <span class="number">50</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/18.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paint.setStrokeWidth(<span class="number">20</span>);</span><br><span class="line">paint.setStrokeCap(Paint.Cap.SQUARE;</span><br><span class="line">canvas.drawPoint(<span class="number">50</span>, <span class="number">50</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/19.png" alt></p>
<p>​        好像有点像 <code>FILL</code> 模式下的 <code>drawCircle()</code> 和 <code>drawRect()</code> ？事实上确实是这样的，它们和 <code>drawPoint()</code> 的绘制效果没有区别。各位在使用的时候按个人习惯和实际场景来吧，哪个方便和顺手用哪个。</p>
<h3 id="画点（批量）"><a href="#画点（批量）" class="headerlink" title="画点（批量）"></a>画点（批量）</h3><p>​        drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint)</p>
<p>​        同样是画点，它和 <code>drawPoint()</code> 的区别是可以画多个点。<code>pts</code> 这个数组是点的坐标，每两个成一对；<code>offset</code> 表示跳过数组的前几个数再开始记坐标；<code>count</code> 表示一共要绘制几个点。说这么多你可能越读越晕，你还是自己试试吧，这是个看着复杂用着简单的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>[] points = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">150</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">// 绘制四个点：(50, 50) (50, 100) (100, 50) (100, 100)</span></span><br><span class="line">canvas.drawPoints(points, <span class="number">2</span> <span class="comment">/* 跳过两个数，即前两个 0 */</span>,</span><br><span class="line">          <span class="number">8</span> <span class="comment">/* 一共绘制 8 个数（4 个点）*/</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/20.png" alt></p>
<h3 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h3><p>​        <strong>drawOval(float left, float top, float right, float bottom, Paint paint)</strong> </p>
<p>​        只能绘制横着的或者竖着的椭圆，不能绘制斜的（斜的倒是也可以，但不是直接使用 <code>drawOval()</code>，而是配合几何变换，后面会讲到）。<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 是这个椭圆的左、上、右、下四个边界点的坐标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Style.FILL);</span><br><span class="line">canvas.drawOval(<span class="number">50</span>, <span class="number">50</span>, <span class="number">350</span>, <span class="number">200</span>, paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Style.STROKE);</span><br><span class="line">canvas.drawOval(<span class="number">400</span>, <span class="number">50</span>, <span class="number">700</span>, <span class="number">200</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/21.png" alt></p>
<p>​        另外，它还有一个重载方法 <code>drawOval(RectF rect, Paint paint)</code>，让你可以直接填写 <code>RectF</code> 来绘制椭圆。</p>
<h3 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h3><p>​        <strong>drawLine(float startX, float startY, float stopX, float stopY, Paint paint)</strong></p>
<p>​        startX<code>,</code>startY<code>,</code>stopX<code>,</code>stopY` 分别是线的起点和终点坐标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawLine(<span class="number">200</span>, <span class="number">200</span>, <span class="number">800</span>, <span class="number">500</span>, paint);</span><br></pre></td></tr></table></figure>



<p>​        由于直线不是封闭图形，所以 <code>setStyle(style)</code> 对直线没有影响。</p>
<h3 id="画线（批量）"><a href="#画线（批量）" class="headerlink" title="画线（批量）"></a>画线（批量）</h3><p>​        <strong>drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint)</strong></p>
<p>​        <code>drawLines()</code> 是 <code>drawLine()</code> 的复数版。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>[] points = &#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">120</span>, <span class="number">20</span>, <span class="number">70</span>, <span class="number">20</span>, <span class="number">70</span>, <span class="number">120</span>, <span class="number">20</span>, <span class="number">120</span>, <span class="number">120</span>, <span class="number">120</span>, <span class="number">150</span>, <span class="number">20</span>, <span class="number">250</span>, <span class="number">20</span>, <span class="number">150</span>, <span class="number">20</span>, <span class="number">150</span>, <span class="number">120</span>, <span class="number">250</span>, <span class="number">20</span>, <span class="number">250</span>, <span class="number">120</span>, <span class="number">150</span>, <span class="number">120</span>, <span class="number">250</span>, <span class="number">120</span>&#125;;</span><br><span class="line">canvas.drawLines(points, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/23.png" alt></p>
<h3 id="画圆角矩形"><a href="#画圆角矩形" class="headerlink" title="画圆角矩形"></a>画圆角矩形</h3><p>​        <strong>drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)</strong></p>
<p>​        <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 是四条边的坐标，<code>rx</code> 和 <code>ry</code> 是圆角的横向半径和纵向半径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawRoundRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">300</span>, <span class="number">50</span>, <span class="number">50</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/24.png" alt></p>
<p>​        另外，它还有一个重载方法 <code>drawRoundRect(RectF rect, float rx, float ry, Paint paint)</code>，让你可以直接填写 <code>RectF</code> 来绘制圆角矩形。</p>
<h3 id="绘制弧形或扇形"><a href="#绘制弧形或扇形" class="headerlink" title="绘制弧形或扇形"></a>绘制弧形或扇形</h3><p>​        <strong>drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</strong> </p>
<p>​        <code>drawArc()</code> 是使用一个椭圆来描述弧形的。<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 描述的是这个弧形所在的椭圆；<code>startAngle</code> 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度），<code>sweepAngle</code> 是弧形划过的角度(所画的弧线的长度)；<code>useCenter</code> 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。</p>
<p><strong>startAngle</strong>弧线的起点的角度:下面分别是 0 和 90 的情况:</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/49.png" alt></p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/50.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.FILL); <span class="comment">// 填充模式</span></span><br><span class="line"><span class="comment">//-110表示逆时针110°，0°在3点钟的位置</span></span><br><span class="line">canvas.drawArc(<span class="number">200</span>, <span class="number">100</span>, <span class="number">800</span>, <span class="number">500</span>, -<span class="number">110</span>, <span class="number">100</span>, <span class="keyword">true</span>, paint); <span class="comment">// 绘制扇形</span></span><br><span class="line">canvas.drawArc(<span class="number">200</span>, <span class="number">100</span>, <span class="number">800</span>, <span class="number">500</span>, <span class="number">20</span>, <span class="number">140</span>, <span class="keyword">false</span>, paint); <span class="comment">// 绘制弧形</span></span><br><span class="line">paint.setStyle(Paint.Style.STROKE); <span class="comment">// 画线模式</span></span><br><span class="line">canvas.drawArc(<span class="number">200</span>, <span class="number">100</span>, <span class="number">800</span>, <span class="number">500</span>, <span class="number">180</span>, <span class="number">60</span>, <span class="keyword">false</span>, paint); <span class="comment">// 绘制不封口的弧形</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/25.png" alt></p>
<p>​        到此为止，以上就是 <code>Canvas</code> 所有的简单图形的绘制。除了简单图形的绘制， <code>Canvas</code> 还可以使用 <code>drawPath(Path path)</code> 来绘制自定义图形。</p>
<h3 id="画自定义图形"><a href="#画自定义图形" class="headerlink" title="画自定义图形"></a>画自定义图形</h3><p>​        <strong>drawPath(Path path, Paint paint)</strong> </p>
<p>​        前面的这些方法，都是绘制某个给定的图形，而 <code>drawPath()</code> 可以绘制自定义图形。当你要绘制的图形比较特殊，使用前面的那些方法做不到的时候，就可以使用 <code>drawPath()</code> 来绘制。</p>
<p>​        <code>drawPath(path)</code> 这个方法是通过描述路径的方式来绘制图形的，它的 <code>path</code> 参数就是用来描述图形路径的对象。<code>path</code> 的类型是 <code>Path</code> ，使用方法大概像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">    Path path = <span class="keyword">new</span> Path(); <span class="comment">// 初始化 Path 对象</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 使用 path 对图形进行描述（这段描述代码不必看懂）</span></span><br><span class="line">      path.addArc(<span class="number">200</span>, <span class="number">200</span>, <span class="number">400</span>, <span class="number">400</span>, -<span class="number">225</span>, <span class="number">225</span>);</span><br><span class="line">      path.arcTo(<span class="number">400</span>, <span class="number">200</span>, <span class="number">600</span>, <span class="number">400</span>, -<span class="number">180</span>, <span class="number">225</span>, <span class="keyword">false</span>);</span><br><span class="line">      path.lineTo(<span class="number">400</span>, <span class="number">542</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">      canvas.drawPath(path, paint); <span class="comment">// 绘制出 path 描述的图形（心形），大功告成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/26.png" alt></p>
<p>​        <code>Path</code> 可以描述直线、二次曲线、三次曲线、圆、椭圆、弧形、矩形、圆角矩形。把这些图形结合起来，就可以描述出很多复杂的图形。下面我就说一下具体的怎么把这些图形描述出来。</p>
<p>​        <code>Path</code> 有两类方法，一类是直接描述路径的，另一类是辅助的设置或计算。</p>
<h4 id="Path-方法第一类：直接描述路径。"><a href="#Path-方法第一类：直接描述路径。" class="headerlink" title="Path 方法第一类：直接描述路径。"></a>Path 方法第一类：直接描述路径。</h4><p>​        这一类方法还可以细分为两组：添加子图形和画线（直线或曲线）</p>
<h5 id="第一组：-addXxx-——添加子图形"><a href="#第一组：-addXxx-——添加子图形" class="headerlink" title="第一组： addXxx() ——添加子图形"></a>第一组： <code>addXxx()</code> ——添加子图形</h5><p><strong>addCircle(float x, float y, float radius, Direction dir) 添加圆</strong></p>
<p>​        <code>x</code>, <code>y</code>, <code>radius</code> 这三个参数是圆的基本信息，最后一个参数 <code>dir</code> 是画圆的路径的方向。</p>
<p>​        路径方向有两种：顺时针 (<code>CW</code> clockwise) 和逆时针 (<code>CCW</code> counter-clockwise) 。对于普通情况，这个参数填 <code>CW</code> 还是填 <code>CCW</code> 没有影响。它只是在<strong>需要填充图形</strong> (<code>Paint.Style</code> 为 <code>FILL</code> 或 <code>FILL_AND_STROKE</code>) ，并且<strong>图形出现自相交</strong>时，用于判断填充范围的。比如下面这个图形：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/27.png" alt></p>
<p>是应该填充成这样呢：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/28.png" alt></p>
<p>还是应该填充成这样呢：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/29.png" alt></p>
<p>​        想用哪种方式来填充，都可以由你来决定。具体怎么做，下面在讲 <code>Path.setFillType()</code> 的时候会详细介绍，而在这里你可以先忽略 <code>dir</code> 这个参数。</p>
<p>​        在用 <code>addCircle()</code> 为 <code>Path</code> 中新增一个圆之后，调用 <code>canvas.drawPath(path, paint)</code> ，就能画一个圆出来。就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path.addCircle(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, Path.Direction.CW);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/30.png" alt></p>
<p>可以看出，<code>path.AddCircle(x, y, radius, dir)</code> + <code>canvas.drawPath(path, paint)</code> 这种写法，和直接使用 <code>canvas.drawCircle(x, y, radius, paint)</code> 的效果是一样的，区别只是它的写法更复杂。所以如果只画一个圆，没必要用 <code>Path</code>，直接用 <code>drawCircle()</code> 就行了。<code>drawPath()</code> 一般是在绘制组合图形时才会用到的。</p>
<p>其他的 <code>Path.add-()</code> 方法和这类似，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addOval(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, Direction dir) / addOval(RectF oval, Direction dir) 添加椭圆</span><br><span class="line">    </span><br><span class="line">addRect(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, Direction dir) / addRect(RectF rect, Direction dir) 添加矩形   </span><br><span class="line">    </span><br><span class="line">addRoundRect(RectF rect, <span class="keyword">float</span> rx, <span class="keyword">float</span> ry, Direction dir) / addRoundRect(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> rx, <span class="keyword">float</span> ry, Direction dir) / addRoundRect(RectF rect, <span class="keyword">float</span>[] radii, Direction dir) / addRoundRect(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span>[] radii, Direction dir) 添加圆角矩形</span><br><span class="line">    </span><br><span class="line">addPath(Path path) 添加另一个 Path</span><br></pre></td></tr></table></figure>

<p>上面这几个方法和 <code>addCircle()</code> 的使用都差不多，不再做过多介绍。</p>
<h5 id="第二组：xxxTo-——画线（直线或曲线）"><a href="#第二组：xxxTo-——画线（直线或曲线）" class="headerlink" title="第二组：xxxTo() ——画线（直线或曲线）"></a>第二组：<code>xxxTo()</code> ——画线（直线或曲线）</h5><p>​        这一组和第一组 <code>addXxx()</code> 方法的区别在于，第一组是添加的完整封闭图形（除了 <code>addPath()</code> ），而这一组添加的只是一条线。</p>
<p><strong>lineTo(float x, float y) / rLineTo(float x, float y) 画直线</strong></p>
<p>​        从<strong>当前位置</strong>向目标位置画一条直线， <code>x</code> 和 <code>y</code> 是目标位置的坐标。这两个方法的区别是，<code>lineTo(x, y)</code> 的参数是<strong>绝对坐标</strong>，而 <code>rLineTo(x, y)</code> 的参数是相对当前位置的<strong>相对坐标</strong> （前缀 <code>r</code> 指的就是 <code>relatively</code> 「相对地」)。</p>
<p><strong>当前位置</strong>：所谓当前位置，即最后一次调用画 <code>Path</code> 的方法的终点位置。初始值为原点 (0, 0)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Style.STROKE);</span><br><span class="line">path.lineTo(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 由当前位置 (0, 0) 向 (100, 100) 画一条直线</span></span><br><span class="line">path.rLineTo(<span class="number">100</span>, <span class="number">0</span>); <span class="comment">// 由当前位置 (100, 100) 向正右方 100 像素的位置画一条直线</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/31.png" alt></p>
<p>​        <strong>quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2) 画二次贝塞尔曲线</strong></p>
<p>​        这条二次贝塞尔曲线的起点就是当前位置，而参数中的 <code>x1</code>, <code>y1</code> 和 <code>x2</code>, <code>y2</code> 则分别是控制点和终点的坐标。和 <code>rLineTo(x, y)</code> 同理，<code>rQuadTo(dx1, dy1, dx2, dy2)</code> 的参数也是相对坐标</p>
<p>​        <strong>贝塞尔曲线</strong>：贝塞尔曲线是几何上的一种曲线。它通过起点、控制点和终点来描述一条曲线，主要用于计算机图形学。概念总是说着容易听着难，总之使用它可以绘制很多圆润又好看的图形，但要把它熟练掌握、灵活使用却是不容易的。不过还好的是，<strong>一般情况下，贝塞尔曲线并没有什么用处，只在少数场景下绘制一些特殊图形的时候才会用到</strong>，所以如果你还没掌握自定义绘制，可以先把贝塞尔曲线放一放，稍后再学也完全没问题。</p>
<p>​        <strong>cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3) 画三次贝塞尔曲线</strong></p>
<p>​        和上面这个 <code>quadTo()</code> <code>rQuadTo()</code> 的二次贝塞尔曲线同理，<code>cubicTo()</code> 和 <code>rCubicTo()</code> 是三次贝塞尔曲线，不再解释</p>
<p>​        <strong>moveTo(float x, float y) / rMoveTo(float x, float y) 移动到目标位置</strong></p>
<p>​        不论是直线还是贝塞尔曲线，都是以当前位置作为起点，而不能指定起点。但你可以通过 <code>moveTo(x, y)</code> 或 <code>rMoveTo()</code> 来改变当前位置，从而间接地设置这些方法的起点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Style.STROKE);</span><br><span class="line">path.lineTo(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 画斜线</span></span><br><span class="line">path.moveTo(<span class="number">200</span>, <span class="number">100</span>); <span class="comment">// 我移~~</span></span><br><span class="line">path.lineTo(<span class="number">200</span>, <span class="number">0</span>); <span class="comment">// 画竖线</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/32.png" alt></p>
<p>​        <code>moveTo(x, y)</code> 虽然不添加图形，但它会设置图形的起点，所以它是非常重要的一个辅助方法。</p>
<p>​        另外，第二组还有两个特殊的方法： <code>arcTo()</code> 和 <code>addArc()</code>。它们也是用来画线的，但并不使用当前位置作为弧线的起点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arcTo(RectF oval, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle, <span class="keyword">boolean</span> forceMoveTo) / arcTo(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle, <span class="keyword">boolean</span> forceMoveTo) / arcTo(RectF oval, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle) 画弧形</span><br></pre></td></tr></table></figure>

<p>​        这个方法和 <code>Canvas.drawArc()</code> 比起来，少了一个参数 <code>useCenter</code>，而多了一个参数 <code>forceMoveTo</code> 。</p>
<p>​        少了 <code>useCenter</code> ，是因为 <code>arcTo()</code> 只用来画弧形而不画扇形，所以不再需要 <code>useCenter</code> 参数；而多出来的这个 <code>forceMoveTo</code> 参数的意思是，绘制是要「抬一下笔移动过去」，还是「直接拖着笔过去」，区别在于是否留下移动的痕迹。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Style.STROKE);</span><br><span class="line">path.lineTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path.arcTo(<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>, -<span class="number">90</span>, <span class="number">90</span>, <span class="keyword">true</span>); <span class="comment">// 强制移动到弧形起点（无痕迹）</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/33.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Style.STROKE);</span><br><span class="line">path.lineTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path.arcTo(<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>, -<span class="number">90</span>, <span class="number">90</span>, <span class="keyword">false</span>); <span class="comment">// 直接连线连到弧形起点（有痕迹）</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/34.png" alt></p>
<p>​        <strong>addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) / addArc(RectF oval, float startAngle, float sweepAngle)</strong></p>
<p>​        又是一个弧形的方法。一个叫 <code>arcTo</code> ，一个叫 <code>addArc()</code>，都是弧形，区别在哪里？其实很简单： <code>addArc()</code> 只是一个直接使用了 <code>forceMoveTo = true</code> 的简化版 <code>arcTo()</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Style.STROKE);</span><br><span class="line">path.lineTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path.addArc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>, -<span class="number">90</span>, <span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/35.png" alt></p>
<p><strong>close() 封闭当前子图形</strong></p>
<p>它的作用是把当前的子图形封闭，即由当前位置向当前子图形的起点绘制一条直线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Style.STROKE);</span><br><span class="line">path.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path.lineTo(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">path.lineTo(<span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line"><span class="comment">// 子图形未封闭</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/36.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Style.STROKE);</span><br><span class="line">path.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path.lineTo(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">path.lineTo(<span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">path.close(); <span class="comment">// 使用 close() 封闭子图形。等价于 path.lineTo(100, 100)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/37.png" alt></p>
<p><code>close()</code> 和 <code>lineTo(起点坐标)</code> 是完全等价的。</p>
<p>​        「子图形」：官方文档里叫做 <code>contour</code> 。但由于在这个场景下我找不到这个词合适的中文翻译（直译的话叫做「轮廓」），所以我换了个便于中国人理解的词：「子图形」。前面说到，第一组方法是「添加子图形」，所谓「子图形」，指的就是一次不间断的连线。一个 <code>Path</code> 可以包含多个子图形。当使用第一组方法，即 <code>addCircle()</code> <code>addRect()</code> 等方法的时候，每一次方法调用都是新增了一个独立的子图形；而如果使用第二组方法，即 <code>lineTo()</code> <code>arcTo()</code> 等方法的时候，则是每一次断线（即每一次「抬笔」），都标志着一个子图形的结束，以及一个新的子图形的开始。</p>
<p>​        另外，不是所有的子图形都需要使用 <code>close()</code> 来封闭。当<strong>需要填充图形时（即 <code>Paint.Style</code> 为 <code>FILL</code> 或 <code>FILL_AND_STROKE</code>）</strong>，<code>Path</code> 会自动封闭子图形。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">paint.setStyle(Style.FILL);</span><br><span class="line">path.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">path.lineTo(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">path.lineTo(<span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line"><span class="comment">// 这里只绘制了两条边，但由于 Style 是 FILL ，所以绘制时会自动封口</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/38.png" alt></p>
<p>以上就是 <code>Path</code> 的第一类方法：直接描述路径的。</p>
<h4 id="Path-方法第二类：辅助的设置或计算"><a href="#Path-方法第二类：辅助的设置或计算" class="headerlink" title="Path 方法第二类：辅助的设置或计算"></a>Path 方法第二类：辅助的设置或计算</h4><h5 id="Path-setFillType-Path-FillType-ft-设置填充方式"><a href="#Path-setFillType-Path-FillType-ft-设置填充方式" class="headerlink" title="Path.setFillType(Path.FillType ft) 设置填充方式"></a>Path.setFillType(Path.FillType ft) 设置填充方式</h5><p>​        前面在说 <code>dir</code> 参数的时候提到， <code>Path.setFillType(fillType)</code> 是用来设置图形自相交时的填充算法的：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/39.png" alt></p>
<p>方法中填入不同的 <code>FillType</code> 值，就会有不同的填充效果。<code>FillType</code> 的取值有四个：</p>
<ul>
<li><code>EVEN_ODD</code></li>
<li><code>WINDING</code> （默认值）</li>
<li><code>INVERSE_EVEN_ODD</code></li>
<li><code>INVERSE_WINDING</code></li>
</ul>
<p>​       其中后面的两个带有 <code>INVERSE_</code> 前缀的，只是前两个的反色版本，所以只要把前两个，即 <code>EVEN_ODD</code> 和 <code>WINDING</code>，搞明白就可以了。</p>
<p>​        <code>EVEN_ODD</code> 和 <code>WINDING</code> 的原理有点复杂，直接讲出来的话信息量太大，所以我先给一个简单粗暴版的总结，你感受一下： <code>WINDING</code> 是「全填充」，而 <code>EVEN_ODD</code> 是「交叉填充」：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/40.png" alt></p>
<p>​        之所以叫「简单粗暴版」，是因为这些只是通常情形下的效果；而如果要准确了解它们在所有情况下的效果，就得先知道它们的原理，即它们的具体算法。</p>
<h4 id="EVEN-ODD-和-WINDING-的原理"><a href="#EVEN-ODD-和-WINDING-的原理" class="headerlink" title="EVEN_ODD 和 WINDING 的原理"></a>EVEN_ODD 和 WINDING 的原理</h4><h5 id="EVEN-ODD"><a href="#EVEN-ODD" class="headerlink" title="EVEN_ODD"></a>EVEN_ODD</h5><p>​        即 even-odd rule （奇偶原则）：对于平面中的任意一点，向任意方向射出一条射线，这条射线和图形相交的次数（相交才算，相切不算哦）如果是奇数，则这个点被认为在图形内部，是要被涂色的区域；如果是偶数，则这个点被认为在图形外部，是不被涂色的区域。还以左右相交的双圆为例：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/41.png" alt></p>
<p>​        射线的方向无所谓，同一个点射向任何方向的射线，结果都是一样的，不信你可以试试。</p>
<p>​        从上图可以看出，射线每穿过图形中的一条线，内外状态就发生一次切换，这就是为什么 <code>EVEN_ODD</code> 是一个「交叉填充」的模式。</p>
<h5 id="WINDING"><a href="#WINDING" class="headerlink" title="WINDING"></a>WINDING</h5><p>即 non-zero winding rule （非零环绕数原则）：首先，它需要你图形中的所有线条都是有绘制方向的：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/42.png" alt></p>
<p>​        然后，同样是从平面中的点向任意方向射出一条射线，但计算规则不一样：以 0 为初始值，对于射线和图形的所有交点，遇到每个顺时针的交点（图形从射线的左边向右穿过）把结果加 1，遇到每个逆时针的交点（图形从射线的右边向左穿过）把结果减 1，最终把所有的交点都算上，得到的结果如果不是 0，则认为这个点在图形内部，是要被涂色的区域；如果是 0，则认为这个点在图形外部，是不被涂色的区域。</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/43.png" alt></p>
<p>和 <code>EVEN_ODD</code> 相同，射线的方向并不影响结果。</p>
<p>​        所以，我前面的那个「简单粗暴」的总结，对于 <code>WINDING</code> 来说并不完全正确：如果你所有的图形都用相同的方向来绘制，那么 <code>WINDING</code> 确实是一个「全填充」的规则；但如果使用不同的方向来绘制图形，结果就不一样了。</p>
<p>​        图形的方向：对于添加子图形类方法（如 <code>Path.addCircle()</code> <code>Path.addRect()</code>）的方向，由方法的 <code>dir</code> 参数来控制，这个在前面已经讲过了；而对于画线类的方法（如 <code>Path.lineTo()</code> <code>Path.arcTo()</code>）就更简单了，线的方向就是图形的方向。</p>
<p>所以，完整版的 <code>EVEN_ODD</code> 和 <code>WINDING</code> 的效果应该是这样的：</p>
<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/44.png" alt></p>
<p>​        而 <code>INVERSE_EVEN_ODD</code> 和 <code>INVERSE_WINDING</code> ，只是把这两种效果进行反转而已，你懂了 <code>EVEN_ODD</code> 和 <code>WINDING</code> ，自然也就懂 <code>INVERSE_EVEN_ODD</code> 和 <code>INVERSE_WINDING</code> 了</p>
<p>​            好，花了好长的篇幅来讲 <code>drawPath(path)</code> 和 <code>Path</code>，终于讲完了。同时， <code>Canvas</code> 对图形的绘制就也讲完了。<strong>图形简单时，使用 <code>drawCircle()</code> <code>drawRect()</code> 等方法来直接绘制；图形复杂时，使用 <code>drawPath()</code> 来绘制自定义图形。</strong></p>
<p>除此之外， <code>Canvas</code> 还可以绘制 <code>Bitmap</code> 和文字。</p>
<h3 id="画-Bitmap"><a href="#画-Bitmap" class="headerlink" title="画 Bitmap"></a>画 Bitmap</h3><p>​        <strong>drawBitmap(Bitmap bitmap, float left, float top, Paint paint)</strong> </p>
<p>​        绘制 <code>Bitmap</code> 对象，也就是把这个 <code>Bitmap</code> 中的像素内容贴过来。其中 <code>left</code> 和 <code>top</code> 是要把 <code>bitmap</code> 绘制到的位置坐标。它的使用非常简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawBitmap(bitmap, <span class="number">200</span>, <span class="number">100</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/45.png" alt></p>
<p>它的重载方法：</p>
<ul>
<li><p><code>drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint)</code> </p>
</li>
<li><p>drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)</p>
</li>
<li><p>drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)</p>
<p>​    <code>drawBitmap</code> 还有一个兄弟方法 <code>drawBitmapMesh()</code>，可以绘制具有网格拉伸效果的 Bitmap。 <code>drawBitmapMesh()</code> 的使用场景较少</p>
</li>
</ul>
<h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p><strong>drawText(String text, float x, float y, Paint paint)</strong> </p>
<p>​        界面里所有的显示内容，都是绘制出来的，包括文字。 <code>drawText()</code> 这个方法就是用来绘制文字的。参数 <code>text</code> 是用来绘制的字符串，<code>x</code> 和 <code>y</code> 是绘制的起点坐标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawText(text, <span class="number">200</span>, <span class="number">100</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/46.jpg" alt></p>
<h4 id="Paint-setTextSize-float-textSize"><a href="#Paint-setTextSize-float-textSize" class="headerlink" title="Paint.setTextSize(float textSize)"></a>Paint.setTextSize(float textSize)</h4><p>通过 <code>Paint.setTextSize(textSize)</code>，可以设置文字的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">paint.setTextSize(<span class="number">18</span>);</span><br><span class="line">canvas.drawText(text, <span class="number">100</span>, <span class="number">25</span>, paint);</span><br><span class="line">paint.setTextSize(<span class="number">36</span>);</span><br><span class="line">canvas.drawText(text, <span class="number">100</span>, <span class="number">70</span>, paint);</span><br><span class="line">paint.setTextSize(<span class="number">60</span>);</span><br><span class="line">canvas.drawText(text, <span class="number">100</span>, <span class="number">145</span>, paint);</span><br><span class="line">paint.setTextSize(<span class="number">84</span>);</span><br><span class="line">canvas.drawText(text, <span class="number">100</span>, <span class="number">240</span>, paint);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/47.png" alt></p>
<h4 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h4><p>Android实现自定义的字体Typeface，正常情况下有两种情况：</p>
<ol>
<li><p>第一种：把字体ttf文件放到assets/fonts目录下，然后通过读取字体文件.ttf获取Typeface，然后在上层Java代码通过setTypeface设置新字体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> app.zhangphil.application;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.graphics.Typeface;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"> </span><br><span class="line">        TextView textView = findViewById(R.id.text);</span><br><span class="line">        textView.setText(<span class="string">"zhang phil"</span>);</span><br><span class="line">        Typeface typeface = Typeface.createFromAsset(getAssets(), <span class="string">"fonts/myfont.ttf"</span>);</span><br><span class="line">        textView.setTypeface(typeface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意字体文件myfont.ttf的存放路径：assets/fonts/myfont.ttf</strong></p>
</li>
<li><p>第二种：在新版的Android系统中，可以通过<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020" target="_blank" rel="noopener">xml</a>配置自定义的字体。具体做法，把自定义的字体库包放到res/font/目录下，然后就可以在xml像配置一般的Android属性一样通过配置android:fontFamily把@font/myfont配置上，自定义字体就设置了。</p>
<ul>
<li><p>把myfont.ttf放到res/font/目录下：</p>
</li>
<li><p>在xml布局中配置字体样式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/text"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:fontFamily</span>=<span class="string">"@font/myfont"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">"zhang phil"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>第三种：承接第二种方案，使用第一种技术方案的实现路线。首先通过读取字体库文件获取Typeface，然后在上层Java代码设置。具体实现，假设在第二种解决方案基础上，已经把myfont.ttf文件放到 res/font/myfont.ttf 位置，然后就可以在上层Java代码像assets读文件一样读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Typeface <span class="title">getTypeface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressLint</span>(<span class="string">"RestrictedApi"</span>)</span><br><span class="line">        Typeface typeface = TypefaceCompat.createFromResourcesFontFile(activity, activity.getResources(), R.font.din_alternate_bold, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> typeface;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>借助getTypeface获取到typeface后，然后在上层Java代码中对TextView通过setTypeface设置字体样式：<br>text.setTypeface(typeface);</p>
</li>
</ol>
<p>关于文本的Api很多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTextSize(<span class="keyword">float</span> textSize)	                                     设置文字大小</span><br><span class="line">setUnderlineText(<span class="keyword">boolean</span> underlineText)	                         设置下划线</span><br><span class="line">setStrikeThruText(<span class="keyword">boolean</span> strikeThruText)	                     设置删除线</span><br><span class="line">setFakeBoldText(<span class="keyword">boolean</span> fakeBoldText)	                         设置文本粗体</span><br><span class="line">setTextSkewX(<span class="keyword">float</span> skewX)	                                     设置文本水平的倾斜度，值可为负数（向右斜）、正数（向左斜）</span><br><span class="line">setTextScaleX(<span class="keyword">float</span> scaleX)	                                     设置水平方向缩放</span><br><span class="line">setLetterSpacing(<span class="keyword">float</span> letterSpacing)                            设置文字间隔</span><br><span class="line">setShadowLayer(<span class="keyword">float</span> radius, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy, <span class="keyword">int</span> shadowColor)设置阴影</span><br><span class="line">setTypeface(Typeface typeface)	                                 设置文本的字体</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p>family：Typeface 类型，指定该类已定义的字体，有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Typeface.DEFAULT          <span class="comment">//常规字体类型</span></span><br><span class="line">Typeface.DEFAULT_BOLD     <span class="comment">//黑体字体类型</span></span><br><span class="line">Typeface.MONOSPACE        <span class="comment">//等宽字体类型</span></span><br><span class="line">Typeface.SANS_SERIF       <span class="comment">//sans serif字体类型</span></span><br><span class="line">Typeface.SERIF            <span class="comment">//serif字体类型</span></span><br></pre></td></tr></table></figure>

<p>familyName：指定系统字体类型，如：“宋体”、”微软雅黑”等</p>
<p>style：指的是样式，常用的字体样式有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Typeface.BOLD        <span class="comment">//粗体</span></span><br><span class="line">Typeface.BOLD_ITALIC <span class="comment">//粗斜体</span></span><br><span class="line">Typeface.ITALIC      <span class="comment">//斜体</span></span><br><span class="line">Typeface.NORMAL      <span class="comment">//常规</span></span><br></pre></td></tr></table></figure>

<p>使用系统字体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mTestPaint.setTextSize(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接设置Typeface对象</span></span><br><span class="line">mTestPaint.setTypeface(Typeface.MONOSPACE);</span><br><span class="line">canvas.drawText(<span class="string">"字体monospace，样式默认"</span>, <span class="number">50</span>, <span class="number">100</span>, mTestPaint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定样式</span></span><br><span class="line">Typeface typeface0 = Typeface.defaultFromStyle(Typeface.ITALIC);</span><br><span class="line">mTestPaint.setTypeface(typeface0);</span><br><span class="line">canvas.drawText(<span class="string">"字体默认，样式斜体"</span>, <span class="number">50</span>, <span class="number">150</span>, mTestPaint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定字体、样式</span></span><br><span class="line">Typeface typeface1 = Typeface.create(Typeface.SANS_SERIF, Typeface.BOLD_ITALIC);</span><br><span class="line">mTestPaint.setTypeface(typeface1);</span><br><span class="line">canvas.drawText(<span class="string">"字体sans serif，样式粗体+斜体"</span>, <span class="number">50</span>, <span class="number">200</span>, mTestPaint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定字体、样式</span></span><br><span class="line">Typeface typeface2 = Typeface.create(<span class="string">"微软雅黑"</span>, Typeface.BOLD);</span><br><span class="line">mTestPaint.setTypeface(typeface2);</span><br><span class="line">canvas.drawText(<span class="string">"字体微软雅黑，样式粗体"</span>, <span class="number">50</span>, <span class="number">250</span>, mTestPaint);</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.it610.com/article/1280459822612889600.htm" target="_blank" rel="noopener">自定义View——Paint 之 文本绘制</a></p>
<p>案例：<a href="https://gitee.com/hluck/custom-view-case.git" target="_blank" rel="noopener">自定义View1</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/28/Compose%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/" rel="prev" title="Compose编程思想">
      <i class="fa fa-chevron-left"></i> Compose编程思想
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/01/Compose%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/" rel="next" title="Compose基础知识2">
      Compose基础知识2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义绘制概述"><span class="nav-number">1.</span> <span class="nav-text">自定义绘制概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义绘制知识的四个级别"><span class="nav-number">2.</span> <span class="nav-text">自定义绘制知识的四个级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一切的开始：onDraw"><span class="nav-number">3.</span> <span class="nav-text">一切的开始：onDraw()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Canvas-drawXXX-和-Paint-基础"><span class="nav-number">4.</span> <span class="nav-text">Canvas.drawXXX() 和 Paint 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#颜色填充"><span class="nav-number">4.1.</span> <span class="nav-text">颜色填充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画圆"><span class="nav-number">4.2.</span> <span class="nav-text">画圆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#坐标系"><span class="nav-number">4.3.</span> <span class="nav-text">坐标系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Paint-setColor-int-color"><span class="nav-number">4.4.</span> <span class="nav-text">Paint.setColor(int color)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Paint-setStyle-Paint-Style-style"><span class="nav-number">4.5.</span> <span class="nav-text">Paint.setStyle(Paint.Style style)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Paint-setStrokeWidth-float-width"><span class="nav-number">4.6.</span> <span class="nav-text">Paint.setStrokeWidth(float width)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抗锯齿"><span class="nav-number">4.7.</span> <span class="nav-text">抗锯齿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画矩形"><span class="nav-number">4.8.</span> <span class="nav-text">画矩形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画点"><span class="nav-number">4.9.</span> <span class="nav-text">画点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画点（批量）"><span class="nav-number">4.10.</span> <span class="nav-text">画点（批量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画椭圆"><span class="nav-number">4.11.</span> <span class="nav-text">画椭圆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画线"><span class="nav-number">4.12.</span> <span class="nav-text">画线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画线（批量）"><span class="nav-number">4.13.</span> <span class="nav-text">画线（批量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画圆角矩形"><span class="nav-number">4.14.</span> <span class="nav-text">画圆角矩形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绘制弧形或扇形"><span class="nav-number">4.15.</span> <span class="nav-text">绘制弧形或扇形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画自定义图形"><span class="nav-number">4.16.</span> <span class="nav-text">画自定义图形</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Path-方法第一类：直接描述路径。"><span class="nav-number">4.16.1.</span> <span class="nav-text">Path 方法第一类：直接描述路径。</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#第一组：-addXxx-——添加子图形"><span class="nav-number">4.16.1.1.</span> <span class="nav-text">第一组： addXxx() ——添加子图形</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第二组：xxxTo-——画线（直线或曲线）"><span class="nav-number">4.16.1.2.</span> <span class="nav-text">第二组：xxxTo() ——画线（直线或曲线）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Path-方法第二类：辅助的设置或计算"><span class="nav-number">4.16.2.</span> <span class="nav-text">Path 方法第二类：辅助的设置或计算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Path-setFillType-Path-FillType-ft-设置填充方式"><span class="nav-number">4.16.2.1.</span> <span class="nav-text">Path.setFillType(Path.FillType ft) 设置填充方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EVEN-ODD-和-WINDING-的原理"><span class="nav-number">4.16.3.</span> <span class="nav-text">EVEN_ODD 和 WINDING 的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#EVEN-ODD"><span class="nav-number">4.16.3.1.</span> <span class="nav-text">EVEN_ODD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WINDING"><span class="nav-number">4.16.3.2.</span> <span class="nav-text">WINDING</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画-Bitmap"><span class="nav-number">4.17.</span> <span class="nav-text">画 Bitmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绘制文字"><span class="nav-number">4.18.</span> <span class="nav-text">绘制文字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Paint-setTextSize-float-textSize"><span class="nav-number">4.18.1.</span> <span class="nav-text">Paint.setTextSize(float textSize)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置字体"><span class="nav-number">4.18.2.</span> <span class="nav-text">设置字体</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="余一"
      src="/images/avatar5.jpg">
  <p class="site-author-name" itemprop="name">余一</p>
  <div class="site-description" itemprop="description">纸上得来终觉浅，绝知此事要躬行。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">172</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/" title="https:&#x2F;&#x2F;www.bilibili.com&#x2F;" rel="noopener" target="_blank">Bilibili</a>
        </li>
    </ul>
  </div>

	
           
         
         <div style="">
  <canvas id="canvas" style="width:60%;">��ǰ�������֧��canvas������������������</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //����canvas�Ŀ���
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //�洢ʱ������
    var data = [];
    //�洢�˶���С��
    var balls = [];
    //�������Ӱ뾶
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //�洢ʱ�����֣���ʮλСʱ����λСʱ��ð�š�ʮλ���ӡ���λ���ӡ�ð�š�ʮλ���ӡ���λ������7���������
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*���ɵ�������*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*����ʱ��*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //ʱ�䷢���仯
            if(NewData[i] !== data[i]){
                //���仯������ֵ����data�����е������洢��changeNumArray������
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //����С��
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*����С��״̬*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*����Ҫ�˶���С��*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*��Ⱦ*/
    function render(){
        //���û������ȣ��ﵽ��ջ�����Ч��
        canvas.height = 100;
        //��Ⱦʱ��
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //��ȾС��
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //����ʱ��
        updateDigitTime();
        //����С��״̬
        updateBalls();
        //��Ⱦ
        render();
    },50);
}

})();
</script>
      </div>
	
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">余一</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">22:38</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

  <script async src="/js/cursor/fireworks.js"></script>

</body>
</html>
