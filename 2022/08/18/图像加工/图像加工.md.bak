# 图像加工

## 图像装饰

### CardView

![](1.png)

```xml
<LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        tools:context=".ui.CardViewActivity">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:gravity="center"
                android:paddingLeft="5dp"
                android:text="卡片视图样式："
                android:textColor="@color/black"
                android:textSize="17sp" />

            <Spinner
                android:id="@+id/sp_card"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:spinnerMode="dialog" />
        </LinearLayout>

        <androidx.cardview.widget.CardView
            android:id="@+id/cv_card"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal|top"
            app:cardCornerRadius="3dp"
            app:cardElevation="3dp"
            app:contentPadding="20dp">

            <ImageView
                android:id="@+id/iv_scene"
                android:layout_width="wrap_content"
                android:layout_height="250dp"
                android:src="@drawable/ylxs" />
        </androidx.cardview.widget.CardView>
    </LinearLayout>
```

activity:

```kotlin
class CardViewActivity : BaseActivity<ActivityCardViewBinding>() {

    private val cardArray = arrayOf("圆角与阴影均为3", "圆角与阴影均为6", "圆角与阴影均为10",
        "圆角与阴影均为15", "圆角与阴影均为20")
    //圆角和阴影值
    private val radiusArray = arrayOf(3, 6, 10, 15, 20)

    override fun ActivityCardViewBinding.initBinding() {
        initSpinner()
    }

    //初始化下拉框
    private fun initSpinner(){
        val adapter = ArrayAdapter<String>(this,R.layout.item_select,cardArray)
        mBinding.apply {
            spCard.prompt = "请选择卡片类型"
            spCard.adapter = adapter
            spCard.onItemSelectedListener = CardSelectedListener()
            spCard.setSelection(0)
        }
    }

    //下拉选择listener
   inner class CardSelectedListener:AdapterView.OnItemSelectedListener{
        override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
            var radius = Utils.dip2px(this@CardViewActivity,radiusArray[position].toFloat()).toFloat()
            mBinding.apply {
                // 设置卡片视图的圆角半径
                cvCard.radius = radius
                // 设置卡片视图的阴影长度
                cvCard.elevation = radius
                val params = cvCard.layoutParams as ViewGroup.MarginLayoutParams
                val marginValue = radius.toInt()
                // 设置布局参数的四周空白
                params.setMargins(marginValue,marginValue,marginValue,marginValue)
                // 设置卡片视图的布局参数
                cvCard.layoutParams = params
            }
        }

        override fun onNothingSelected(parent: AdapterView<*>?) {}
    }
}
```

![](2.png)

### 给图像添加装饰

​		有时需要给图片添加一些小装饰，比如添加图片边框、添加文字水印、添加图标水印等,为此要求自定义图像控件，重写视图的onDraw方法，利用画布工具Canvas来绘制图案。

Canvas相关用法：[自定义View](https://hluck.gitee.io/2022/06/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%80/)

效果图：

![](3.png)

1. 加文本：

   ![](4.png)

2. 加logo图：

   ![](5.png)

3. 加相框

   ![](6.png)

DecorateImageView:

```kotlin
class DecorateImageView(context: Context, attrs:AttributeSet): ImageView(context, attrs) {
    // 声明一个画笔对象
    private val mPaint = Paint()
    // 视图宽度、视图高度
    private var mWidth:Int = 0
    private var mHeight:Int = 0
    // 文字大小
    private var mTextSize:Int = 20
    // 时间戳文本
    private var mText:String = ""
    // 标志图标
    private var mLogo:Bitmap? = null
    // 照片相框
    private var mFrame:Bitmap? = null

    init {
        // 设置画笔颜色
//        mPaint.color = Color.WHITE
        mPaint.setColor(Color.parseColor("#FFFFFF"))
//        mPaint.setColor(Color.parseColor("#FFFFFF"))
        // 设置文字大小
        mPaint.textSize = Utils.dip2px(context,mTextSize.toFloat()).toFloat()
        mPaint.isAntiAlias = true
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        // 获取视图的实际宽度
        mWidth = measuredWidth
        // 获取视图的实际高度
        mHeight = measuredHeight
    }

    @SuppressLint("DrawAllocation")
    override fun onDraw(canvas: Canvas?) {
        super.onDraw(canvas)
        if (!TextUtils.isEmpty(mText)){
            //获取指定文本高度
            val textHeight = MeasureUtil.getTextHeight(mText,mTextSize.toFloat())
            //在画布上绘制文本
//            canvas?.drawText(mText,0f,mHeight - textHeight,mPaint)
            canvas?.drawText(mText,mHeight-95f,textHeight,mPaint)
        }
        mFrame?.let {
            canvas?.drawBitmap(it,null, Rect(0,0,mWidth,mHeight),mPaint)
        }
        mLogo?.let {
            canvas?.drawBitmap(it,(mWidth-it.width - 100).toFloat(),(mHeight - it.height).toFloat(),mPaint)
        }
    }

    //不显示任何装饰
    fun showNone(){
        mText = ""
        mLogo = null
        mFrame = null
        // 立即刷新视图（线程安全方式）
        postInvalidate()
    }

    //显示装饰文本
    fun showText(text:String,isReset:Boolean){
        if (isReset){
            showNone()
        }
        mText = text
        postInvalidate()
    }

    //设置文字字体
    fun setTypeface(typeface: Typeface){
        //设置文字字体
        mPaint.typeface = typeface
    }

    // 显示装饰标志
    fun showLogo(bitmap: Bitmap,isReset:Boolean){
        if (isReset){
            showNone()
        }
        mLogo = bitmap
        postInvalidate()
    }

    // 显示装饰相框
    fun showFrame(bitmap: Bitmap,isReset:Boolean){
        if (isReset){
            showNone()
        }
        mFrame = bitmap
        postInvalidate()
    }
}
```

### 给图像加水波纹

效果：

![](7.gif)

RippleImageView:

```kotlin
@SuppressLint("AppCompatCustomView")
class RippleImageView(context: Context, attrs:AttributeSet):ImageView(context, attrs) {

    private val mContext = context
    // 声明一个画笔对象
    private val mPaint = Paint()
    // 视图宽度、视图高度
    private var mWidth = 0
    private var mHeight = 0
    // 水波的半径
    private var mRadius = 0
    // 半径的增量
    private var mIncrease = 0
    // 声明一个处理器对象
    private val mHandler = Handler(Looper.myLooper()!!)

    init {
        mPaint.isAntiAlias = true
        mIncrease = Utils.dip2px(mContext,5F)
        mPaint.color = Color.WHITE
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        // 获取视图的实际宽度
        mWidth = measuredWidth
        // 获取视图的实际高度
        mHeight = measuredHeight
    }

    override fun onDraw(canvas: Canvas?) {
        super.onDraw(canvas)
        if (mRadius > 0){
            canvas?.drawCircle((mWidth/2).toFloat(),(mHeight/2).toFloat(),mRadius.toFloat(),mPaint)
        }
    }
    // 设置水波的颜色
    fun setRippleColor(color:String){
        mPaint.color = Color.parseColor(color)
    }

    // 开始播放水波动画
    fun startRipple(){
        mRadius = 0
        // 立即启动水波刷新任务
        mHandler.post(mRipple)
    }

    // 定义一个水波刷新任务
    private val mRipple = object :Runnable{
        override fun run() {
            mRadius += mIncrease
            // 水波半径已超出对角线
            if (mRadius*mRadius > (mWidth*mWidth/4 + mHeight*mHeight/4)){
                mRadius = 0
                mIncrease = Utils.dip2px(mContext,5f)
            }else{// 水波半径未超出对角线
                mIncrease += Utils.dip2px(mContext,1f)
                // 延迟50毫秒后再次启动水波刷新任务
                mHandler.postDelayed(this,100)
            }
            // 立即刷新视图（线程安全方式）
            postInvalidate()
        }
    }
}
```

## 位图加工

### 转换位图的像素色彩

​		滤镜特效的加工处理用到了位图工具**Bitmap**，它有主要的三个操作方法，现说明如下：

- createBitmap：创建一个新位图。
- getPixels：获取位图对象所有点的像素数组。
- setPixels：设置位图对象所有点的像素数组。

更详细的位图加工步骤说明如下：

1. 调用createBitmap方法创建新的空白位图。
2. 调用原位图的getPixels方法，把该位图所有像素的色值保存到指定的像素点数组。
3. 遍历第二步得到的像素点数组，分别获取每个点的灰度、红色、绿色以及蓝色的色值，并按照特定算法调整该点的色值。
4. 像素点数组全部调整完毕之后，调用新位图的setPixels方法更新所有像素的色值。

上面四个步骤都做完之后得到的便是经过特效处理的新位图了。

以常见的几种特效处理为例，它们的加工算法描述如下：

1. 黑白效果：黑白照片对于彩色照片来说，就好比黑白电视机之于彩色电视机，黑白照片只有灰度的深浅区别，而没有红绿蓝之分。
2. 怀旧效果：现实生活中的老照片都是泛黄的，而黄色又是由绿色和红色混合而成的，所以怀旧效果为了突出黄色，就得加大绿色和红色的比重，同时降低蓝色的比重。
3. 底片效果：在数码相机时代之前，占统治地位的是胶卷相机，胶卷底片与洗出来的照片相比，底片的RGB值就是照片的RGB值取反，即：底片的红色=255-照片的红色，底片的绿色=255-照片的绿色，底片的蓝色=255-照片的蓝色。
4. 模糊效果：要让图片变得模糊起来，每个点的颜色都由附近一片像素颜色混合而成，这样图片中每个景物的边缘就变模糊了。

原图：

![](7.png)

黑白：

![](8.png)

底片：

![](9.png)

怀旧：

![](10.png)

模糊：

![](11.png)

### 裁剪位图内部区域

效果：

![](12.png)

### 利用矩阵变换位图

​		Android还支持缩放、旋转、平移等变换操作，不过位图工具不能直接完成这些操作，而要借助于矩阵工具Matrix。

​		下面是Matrix工具常用的几个矩阵变换方法：

- postScale：指定横纵坐标两个方向的缩放比率。

- postRotate：指定旋转角度。

- postTranslate：指定横纵坐标两个方向的偏移大小。

- postSkew：指定横纵坐标两个方向的倾斜比例。

  ​		注意上述的几个变换方法仅仅设定了矩阵的变换形式，还得把矩阵对象传给位图工具的createBitmap方法，如此方能完成位图对象的变换操作。

​       以postScale方法为例，它的两个参数分别表示横坐标和纵坐标方向的缩放比率，值为0.5表示缩小成原来的一半，值为2表示放大成原来的两倍。这个比率值还可以是负数，表示在该方向上翻转，即镜像。比如postScale(-1, 1)表示在横坐标上翻转，且纵坐标上保持不变，最终便是镜子那样的水平镜像效果。

原始：

![](13.png)

翻转：

![](14.png)



## 自定义图形

​		内容包括如何在位图和图形之间相互转换以及将位图转换为图形的必要性、如何利用位图着色器剪裁图形内部的指定区域、如何通过画笔在图形内部添加小部件等。

### 位图与图形互转

​		Android的图形管理使用图形工具Drawable类，位图管理使用位图工具Bitmap类。其中，Drawable用于在界面上展示图片，Bitmap用于加工图像数据。

​		位图图形BitmapDrawable正是二者之间的桥梁，图形对象与位图对象互转都需要它。其中，Bitmap转Drawable的代码如下所示：

```java
// 把位图对象转换为图形对象     
Drawable drawable = new BitmapDrawable(getResources(), bitmap);
```

Drawable转Bitmap的代码如下所示：

```java
// 把图形对象转换为位图对象    
Bitmap bitmap = ((BitmapDrawable)drawable).getBitmap();
```

图形对象转成位图对象有个前提，就是该图形原本便是位图格式，否则会转换失败。

​		位图对象为什么要转成图形对象呢？（ImageView已经存在setImageBitmap方法，根本不用转成图形对象后再调用setImageDrawable方法）这是因为有很多控件只支持设置图形，不支持设置位图，包括但不限于下列场合：

1. 视图基类View，调用setBackground方法设置背景图形。
2. 文本视图TextView，调用setCompoundDrawables方法设置上下左右四方向的图标。
3. 复合按钮CompoundButton，调用setButtonDrawable方法设置左侧的勾选图标。

​       此外，位图对象转成图形对象之后能够调用Drawable的各个方法。例如，Drawable类有个setAlpha方法，可以设置图形的灰度值。其值为255时表示不透明，此时图形正常显示；其值为0时表示全透明，此时图形完全消失；其值为127时为半透明，此时图形若隐若现。

![](15.png)

### 剪裁图形内部区域

​		调用画笔工具的setShader方法，设置位图着色器之后再调用画布工具的draw***方法即可剪裁出指定几何形状的图像。

CircleDrawable:

```kotlin
class CircleDrawable(context: Context,bitmap: Bitmap): BitmapDrawable(context.resources,bitmap) {
    // 声明一个画笔对象
    private val mPaint = Paint()

    init {
        // 创建一个位图着色器，CLAMP表示边缘拉伸
        val shader = BitmapShader(bitmap,Shader.TileMode.CLAMP,Shader.TileMode.CLAMP)
        // 设置画笔的着色器对象
        mPaint.shader = shader
    }

    override fun draw(canvas: Canvas) {
        val width = bitmap.width
        val height = bitmap.height
        val radius = Math.min(width,height) / 2 - 4
        // 在画布上绘制圆形，也就是只显示圆形内部的图像
        canvas.drawCircle((width/2).toFloat(), (height/2).toFloat(), radius.toFloat(),mPaint)
    }
}
```

![](16.png)

### 给图形添加小部件

​		除了剪裁图形之外，还能给图形添加小部件，比如文字、图标等。原来自定义图形类的时候，重写draw方法等同于重写视图的onDraw方法，因此在draw方法中挥毫泼墨就能添加图案。

​		以添加文字为例，自定义图形之时，重写draw方法并调用画布对象的drawText方法，即可往图形中加入文字标记。为了让文字更加多姿，还能设置个性化字体，此时用到了字体工具Typeface的createFromAsset方法，该方法允许从assets目录下的字体文件生成字体对象，然后调用画笔对象的setTypeface方法，就能使文字呈现对应的字体样式，像Windows系统常见的楷体、隶书等皆可为我所用。

#### 添加文字水印

![](17.png)

#### 添加logo水印

![](18.png)

MarkIconDrawable.kt:

```kotlin
/**
 *
 * @Author： LJH
 * @Time： 2022/8/24
 * @description：
 */
class MarkIconDrawable(context: Context, bitmap: Bitmap): BitmapDrawable(context.resources,bitmap) {
    private val mPaint = Paint()
    // 水印图标
    private var marker:Bitmap? = null
    // 水印方位
    private var mDirection = 0

    init {
        mPaint.color = Color.parseColor("#FFFFFFFF")
    }

    // 设置水印图标及其方位
    fun setMarkerIcon(bitmap: Bitmap,direction:Int){
        val originHeight = getBitmap().height
        val markerHeight = bitmap.height
        val ratio:Double = 1.0 * originHeight / markerHeight / 3
        // 创建缩放后的水印图标
        marker = BitmapUtil.getScaleBitmap(bitmap,ratio)
        mDirection = direction
    }

    override fun draw(canvas: Canvas) {
        //注意：这句话不能删，否则原图不显示
        super.draw(canvas)
        if (marker == null){
            return
        }
        val widthGap = bitmap.width - marker!!.width
        Log.e("Tag","$widthGap")
        val heightGap = bitmap.height - marker!!.height
        Log.e("Tag","$heightGap")
        when(mDirection){
            // 在中间
            0 -> canvas.drawBitmap(marker!!,(widthGap/2).toFloat(),(heightGap/2).toFloat(),mPaint)
            // 左上角
            1 -> canvas.drawBitmap(marker!!,0f,0f,mPaint)
            // 右上角
            2 -> canvas.drawBitmap(marker!!,widthGap.toFloat(),0f,mPaint)
            // 左下角
            3 -> canvas.drawBitmap(marker!!,0f,heightGap.toFloat(),mPaint)
            // 右下角
            4 -> canvas.drawBitmap(marker!!,widthGap.toFloat(),heightGap.toFloat(),mPaint)
        }
    }
}
```



## 大头贴案例

​													![](19.png)

![](20.png)

### 动态请求权限

```java
import android.app.Activity;
import android.content.pm.PackageManager;
import android.os.Build;

import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

public class PermissionUtil {
    private final static String TAG = "PermissionUtil";

    // 检查某个权限。返回true表示已启用该权限，返回false表示未启用该权限
    public static boolean checkPermission(Activity act, String permission, int requestCode) {
        return checkPermission(act, new String[]{permission}, requestCode);
    }

    // 检查多个权限。返回true表示已完全启用权限，返回false表示未完全启用权限
    public static boolean checkPermission(Activity act, String[] permissions, int requestCode) {
        boolean result = true;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            int check = PackageManager.PERMISSION_GRANTED;
            // 通过权限数组检查是否都开启了这些权限
            for (String permission : permissions) {
                check = ContextCompat.checkSelfPermission(act, permission);
                if (check != PackageManager.PERMISSION_GRANTED) {
                    break; // 有个权限没有开启，就跳出循环
                }
            }
            if (check != PackageManager.PERMISSION_GRANTED) {
                // 未开启该权限，则请求系统弹窗，好让用户选择是否立即开启权限
                ActivityCompat.requestPermissions(act, permissions, requestCode);
                result = false;
            }
        }
        return result;
    }

    // 检查权限结果数组，返回true表示都已经获得授权。返回false表示至少有一个未获得授权
    public static boolean checkGrant(int[] grantResults) {
        boolean result = true;
        if (grantResults != null) {
            for (int grant : grantResults) { // 遍历权限结果数组中的每条选择结果
                if (grant != PackageManager.PERMISSION_GRANTED) { // 未获得授权
                    result = false;
                }
            }
        } else {
            result = false;
        }
        return result;
    }

}
```

## 项目地址

[项目地址](https://gitee.com/hluck/image-processing)